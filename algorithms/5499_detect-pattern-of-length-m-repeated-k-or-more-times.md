[TOC]

# Problem

给你一个正整数数组 arr，请你找出一个长度为 m 且在数组中至少重复 k 次的模式。

模式 是由一个或多个值组成的子数组（连续的子序列），连续 重复多次但 不重叠 。 模式由其长度和重复次数定义。

如果数组中存在至少重复 k 次且长度为 m 的模式，则返回 true ，否则返回  false 。

 

示例 1：

```
输入：arr = [1,2,4,4,4,4], m = 1, k = 3
输出：true
解释：模式 (4) 的长度为 1 ，且连续重复 4 次。注意，模式可以重复 k 次或更多次，但不能少于 k 次。
```


示例 2：

```
输入：arr = [1,2,1,2,1,1,1,3], m = 2, k = 2
输出：true
解释：模式 (1,2) 长度为 2 ，且连续重复 2 次。另一个符合题意的模式是 (2,1) ，同样重复 2 次。
```


示例 3：

```
输入：arr = [1,2,1,2,1,3], m = 2, k = 3
输出：false
解释：模式 (1,2) 长度为 2 ，但是只连续重复 2 次。不存在长度为 2 且至少重复 3 次的模式。
```


示例 4：

```
输入：arr = [1,2,3,1,2], m = 2, k = 2
输出：false
解释：模式 (1,2) 出现 2 次但并不连续，所以不能算作连续重复 2 次。
```


示例 5：

```
输入：arr = [2,2,2,2], m = 2, k = 3
输出：false
解释：长度为 2 的模式只有 (2,2) ，但是只连续重复 2 次。注意，不能计算重叠的重复次数。
```


提示：

```
2 <= arr.length <= 100
1 <= arr[i] <= 100
1 <= m <= 100
2 <= k <= 100
```



# Solution

## 分析和思路

这道题目考虑的是**模式匹配**，是正则表达式中常用的套路。

对于数组中出现的重复的模式，应该从前往后遍历检测，对于一个长度为 n 的数组，如果要找出长度为 m 的模式重复 k 次，有以下几种情况：

1. m * k < n

由于不重叠的特性，那么不可能出现这种模式，返回 false

2. m * k > n

如果有可能出现模式，需要从前往后遍历检测，每当检测一个新的长度为 m 的模式，当剩下的字符串位数 `left_count < m * k` 时候，直接返回 false ，否则开始往后遍历检测



这道题目比较简单，但是需要考虑的东西比较多



## C++

执行用时：4 ms, 在所有 C++ 提交中击败了100.00%的用户

内存消耗：8.2 MB, 在所有 C++ 提交中击败了100.00%的用户

```cpp
class Solution {
    public:
    bool containsPattern(vector<int> &arr, int m, int k){
        int len = arr.size();
        int show_times = 0;     // 模式出现的次数
        vector<int> temp_patt(m);       // 保存临时的模式数组
        for (int i = 0; i < len; i++){
            
            // 如果当前剩余的元素个数 小于 必须满足的最少元素条件，那么直接返回 false
            if ((len - i) < m * k)
                return false;
            
            // 保存新的数组，进行测试是否满足模式
            for (int j = 0; j < m; j++){
                temp_patt[j] = arr[i+j];
            }

            show_times++;   // 出现 1 次
            // 保存下一个模式可能出现的起始和结束位置
            int next_start = i + m, next_end = i + 2*m - 1;
            while (next_end < len) {  // 保证数组不越界
                int j;
                // 检查下一个可能出现的模式的位置是否和当前模式相同
                for (j = 0; j < m; j++){
                    if(temp_patt[j] != arr[next_start + j])
                        break;
                }
                if (j == m) {   // 完全相同
                    next_start += m;
                    next_end += m;
                    show_times++;
                    if(show_times == k) {
                        return true;
                    }
                }else {     // 和之前的模式不相同
                    break;
                }

            }
            
            show_times = 0; // 当前模式不匹配，恢复成 0    
        }        
        return false;
    }
};
```





## Java