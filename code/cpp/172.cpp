#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // 如果要末尾出现 0，那么一定是 乘以 10了，如果要出现 10，那么就需要出现 5 * 2
    // 这是在 0~9 的数字里唯一能够出现的，所以找到所有因数里面 5 * 2 的个数
    // 以 11! = 11 * (5 * 2) * 9 * (4 * 2) * 7 * (3 * 2) * 5 * 4 * ...
    // 可以看到含有2的因数有 2，3*2，4*2...
    // 含有 5 的因数有 5，5*2，...
    // 5 的个数远远多于 2 的个数，所以只需要在找到因数 5 的个数
    // 但是如果遍历每个数字，找到每个数字里含有 5 的因数，那么也非常慢
    // 观察发现，每隔 5 个数出现一个 5，例如 1*5,2*5,3*5...
    // 每隔 25 个数字，出现两个 5，5*5， 2*5*5，。。。
    // 每隔 125 个数字，出现三个 5，可以看到规律，先找到所有出现 一个 5 的个数，再找出现 两个5的个数...
        
    int trailingZeroes(int n) {
        int cnt = 0;
        while (n) {
            n /= 5;
            cnt += n;
        }
        return cnt;
    }   
};

int main(int argc, char const* argv []) {




    return 0;
}